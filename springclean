#!/usr/bin/env python

# springclean - process and cleanup (log) files
# Copyright James Powell jamespo [at] gmail [dot] com - 2013

import sys, re, os
import fnmatch
import time
from operator import lt, gt
from optparse import OptionParser

class SpringClean(object):
    def __init__(self, options):
        self.options = options
        self.status = None

    def run(self):
        if self.find_matches():
            self.perform_action()

    def find_matches(self):
        '''find filename matches based on conditions passed'''
        try:
            os.chdir(self.options.dir)
        except OSError, excep:
            self.status = excep[1] + ' ' + self.options.dir
            return False
        # get all files, then filter
        files = [file for file in os.listdir(".")]
        if self.options.matchre is not None:
            files = self.matchre_files(files)
        if self.options.mtime_older is not None:
            files = self.match_mtime_files(files, lt, self.options.mtime_older)
        elif self.options.mtime_newer is not None:
            files = self.match_mtime_files(files, gt, self.options.mtime_newer)
        self.files = files
        return True

    def matchre_files(self, files):
        '''match files against regex'''
        mre = re.compile(self.options.matchre)
        refiles = [file for file in files if re.search(mre, file) is not None]
        return refiles

    def match_mtime_files(self, files, oper, time_param):
        '''match files mtime against now - delta'''
        # oper is either lt or gt
        timeunit = None
        timematch = re.search(r'^(\d+)(d|h|m|s)?$', time_param)
        if timematch.group(2) is not None:
            timeunit = timematch.group(2)
        else:
            # default timeunit is days
            timeunit = 'd'
        timearg = int(timematch.group(1))
        threshold = self.calc_time(timearg, timeunit)
        mt_files = [file for file in files if oper(os.stat(file).st_mtime, threshold)]
        return mt_files

    @staticmethod
    def calc_time(timediff, unit = 'd'):
        '''takes # of time units & the unit & subtracts from current date/time'''
        secs_to_unit = { 'd' : 86400,
                         'h' : 3600,
                         'm' : 60,
                         's' : 1 }
        now_time_epoch = int(time.mktime(time.localtime()))
        time_compare_thresh = timediff * secs_to_unit[unit]
        time_threshold = now_time_epoch - time_compare_thresh
        return time_threshold

    def perform_action(self):
        '''perform the selected action'''
        numfiles = 0
        actioned = {    'list' : 'Listed',
                        'gzip' : 'Gzipped',
                        'rm'   : 'Deleted' }
        if self.options.action == 'list':
            numfiles = self.process_files(self.list_file)
        elif self.options.action == 'rm':
            numfiles = self.process_files(self.remove_file)
        elif self.options.action == 'gzip':
            numfiles = self.process_files(self.gzip_file)
        self.post_action_output(actioned[self.options.action], numfiles)

    @staticmethod
    def post_action_output(operation, numfiles):
        '''display post operation summary'''
        filetxt = 'files'
        if numfiles == 1:
            filetxt = 'file'
        print "%s %s %s" % (operation, numfiles, filetxt)

    def gzip_file(self):
        pass

    def process_files(self, action):
        '''run action on ecach file in self.files'''
        num_processed = 0
        for file in self.files:
            if self.options.confirm:
                if self.confirm_action(file):
                    action(file)
                    num_processed += 1
            else:
                # no confirmation required
                action(file)
                num_processed += 1
        return num_processed

    def confirm_action(self, file):
        '''confirm action is to be run'''
        return self.query_yes_no("About to %s %s. Are you sure" % (self.options.action, file))

    @staticmethod
    def query_yes_no(question, default="yes"):
        """Ask a yes/no question via raw_input() and return their answer.

        "question" is a string that is presented to the user.
        "default" is the presumed answer if the user just hits <Enter>.
            It must be "yes" (the default), "no" or None (meaning
            an answer is required of the user).

        The "answer" return value is one of "yes" or "no".
        """
        valid = {"yes":True,   "y":True,  "ye":True,
                 "no":False,     "n":False}
        if default == None:
            prompt = " [y/n] "
        elif default == "yes":
            prompt = " [Y/n] "
        elif default == "no":
            prompt = " [y/N] "
        else:
            raise ValueError("invalid default answer: '%s'" % default)

        while True:
            sys.stdout.write(question + prompt)
            choice = raw_input().lower()
            if default is not None and choice == '':
                return valid[default]
            elif choice in valid:
                return valid[choice]
            else:
                sys.stdout.write("Please respond with 'yes' or 'no' " \
                                 "(or 'y' or 'n').\n")


    def list_file(self, file):
        print self.options.dir + '/' + file

    def remove_file(self, file):
        os.remove(self.options.dir + '/' + file)


def bombout(reason):
    '''quit with error message'''
    print "Error: " + reason
    sys.exit(0)

def checkopts(options):
    '''validate passed options'''
    if options.match is None and options.matchre is None and options.mtime_older is None\
        and options.mtime_newer is None:
        bombout("No file matching arguments specified")
    elif options.match is not None and options.matchre is not None:
        bombout("Choose one of match and matchre arguments")
    elif options.mtime_older is not None and options.mtime_newer is not None:
        bombout("Choose one of older or newer conditions")

def main():
    parser = OptionParser()
    parser.add_option("--dir", dest="dir", help="directory to match from (default $PWD)",
                      default=os.getcwd())
    parser.add_option("-c", "--confirm", help="confirm each individual operatio (rm|gzip|mv)",
                      action="store_true", dest="confirm", default=False)
    parser.add_option("-m", "--match", dest="match",
                      help="shell-style wildcard to match logfiles to process")
    parser.add_option("-x", "--matchre", dest="matchre",
                      help="regex to match logfiles to process")
    parser.add_option("-n", "--newer", dest="mtime_newer",
                      help="match files newer than x days")
    parser.add_option("-o", "--older", dest="mtime_older",
                      help="match files older than x days")
    parser.add_option("-a", "--action", dest="action", default="list",
                      choices=['rm','list','gzip','mv'],
                      help="action on matched files (rm|list|gzip|mv) default - list")
    (options, args) = parser.parse_args()
    checkopts(options)
    sc = SpringClean(options)
    rc = sc.run()
    #print sc.status

if __name__ == '__main__':
    main()
